**Алгоритмы сортировки**  
* Пузырьковая сортировка (Bubble Sort): **O**(n²)
* Сортировка выбором (Selection Sort): **O**(n²)
* Сортировка вставками (Insertion Sort): **O**(n) - **O**(n²)
* Сортировка слиянием (Merge Sort): **O**(n log n)
* Быстрая сортировка (Quick Sort): **O**(n log n) - **O**(n²)
* Сортировка подсчетом (Counting Sort): **O**(n + k)
* Пирамидальная сортировка (Heapsort): **O**(n log n)

**Алгоритмы поиска**  
* Линейный поиск (Linear Search): **O**(n)
* Бинарный поиск (Binary Search): **O**(log n)

**Алгоритмы на графах (V - вершины, E - ребра)**  
* Поиск в ширину (Breadth-First Search, BFS): **O**(V + E)
* Поиск в глубину (Depth-First Search, DFS): **O**(V + E)
* Алгоритм Дейкстры (Dijkstra's Algorithm) (для разреженных графов с кучей): **O**((V + E) log V)
* Алгоритм Беллмана-Форда (Bellman-Ford Algorithm): **O**(V * E)
* Алгоритм Флойда-Уоршелла (Floyd-Warshall Algorithm) (Все пары кратчайших путей): **O**(V³)
* Топологическая сортировка (Topological Sorting) (DFS-based): **O**(V + E)

**Простые операции**  
* Нахождение максимума/минимума в массиве: **O**(n) - Требуется один проход по всем n элементам для сравнения
* Доступ к элементу массива по индексу: **O**(1) - Адрес элемента вычисляется за константное время по базовому адресу и смещению (индексу)
* Вставка/Удаление <ins>в начало</ins> связного списка: **O**(1) - Требуется только обновление нескольких указателей (головы списка и первого узла)
* Вставка/Удаление в конец связного списка (без указателя на хвост): **O**(n) - Требуется пройти весь список от головы до текущего последнего элемента, чтобы найти место для вставки/удаления
* Вставка/Удаление в конец связного списка (с указателем на хвост): **O**(1) для вставки, **O**(n) для удаления (если нет указателя на предыдущий элемент)
* Поиск элемента в связном списке: **O**(n) - В худшем случае нужно пройти весь список

**Ключевые выводы**  
* Константное время **O**(1): Идеально (доступ по индексу в массиве, вставка в начало списка)
* Логарифмическое время **O**(log n): Очень эффективно для больших n (бинарный поиск, операции в куче)
* Линейное время **O**(n): Приемлемо, часто неизбежно при обработке всех элементов (линейный поиск, нахождение максимума, обход списка)
* Линеарифмическое время **O**(n log n): Эффективные алгоритмы сортировки общего назначения (Merge Sort, Quick Sort avg, Heap Sort)
* Квадратичное время **O**(n²): Медленно для больших n, характерно для простых сортировок (Bubble, Selection, Insertion worst/avg), например, когда есть вложенные циклы, то есть цикл в цикле
* Кубическое время **O**(n³): Очень медленно (Floyd-Warshall)
* Зависимость от параметров: Сложность может зависеть от нескольких параметров задачи (**O**(V + E) для графов, **O**(n + k) для Counting Sort)
